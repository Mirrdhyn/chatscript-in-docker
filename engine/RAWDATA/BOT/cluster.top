# Kubernetes Cluster Resources FAQ - bilingual EN/FR
# Covers: Namespace, Node, Event

# =============================================================================
# NAMESPACE
# =============================================================================

topic: ~namespace (namespace namespaces espace isolation "espace de noms" finalizer finalizers terminating active)

#! what is a namespace
u: (<< [what que "qu est-ce"] [is est] [a un une] namespace >>)
	^keep() A Namespace is a mechanism for isolating groups of resources within a single Kubernetes cluster. Namespaces provide a scope for names: resource names must be unique within a namespace but not across namespaces. They are intended for use in environments with many users spread across multiple teams or projects. \n
	Un Namespace est un mecanisme d'isolation de groupes de ressources au sein d'un meme cluster Kubernetes. Les Namespaces fournissent une portee pour les noms : les noms de ressources doivent etre uniques dans un namespace mais pas entre namespaces. Ils sont destines aux environnements avec de nombreux utilisateurs repartis sur plusieurs equipes ou projets.

#! default namespaces in kubernetes
u: (<< [default defaut] [namespace namespaces] >>)
	^keep() Kubernetes creates four default namespaces: \n
	- default: the namespace for resources with no other namespace specified. \n
	- kube-system: the namespace for objects created by the Kubernetes system (e.g. kube-dns, kube-proxy, etcd, controller-manager). \n
	- kube-public: readable by all users (including unauthenticated ones), reserved for cluster-wide visible resources. \n
	- kube-node-lease: holds Lease objects associated with each node, used by the kubelet to send heartbeats so the control plane can detect node failures. \n
	Kubernetes cree quatre namespaces par defaut : default (ressources sans namespace specifie), kube-system (objets du systeme Kubernetes), kube-public (lisible par tous, meme non authentifies) et kube-node-lease (contient les objets Lease associes a chaque noeud pour les heartbeats du kubelet).

#! namespace finalizers
u: (<< namespace [finalizer finalizers finaliseur finaliseurs] >>)
	^keep() Namespace finalizers prevent a Namespace from being fully deleted until cleanup is complete. The default finalizer is 'kubernetes', which ensures that all resources within the namespace are deleted before the namespace itself is removed. If a finalizer gets stuck (e.g. a controller is unavailable), the namespace remains in the Terminating phase indefinitely. Removing the stuck finalizer manually via the API allows deletion to complete, but may leave orphaned resources. \n
	Les finalizers de Namespace empechent la suppression complete d'un Namespace tant que le nettoyage n'est pas termine. Le finalizer par defaut est 'kubernetes', qui garantit que toutes les ressources du namespace sont supprimees avant le namespace lui-meme. Si un finalizer est bloque, le namespace reste en phase Terminating indefiniment. Supprimer manuellement le finalizer bloque via l'API permet la suppression, mais peut laisser des ressources orphelines.

#! namespace phases active terminating
u: (<< namespace [phase phases etat etats status statut active terminating] >>)
	^keep() A Namespace has two possible phases: \n
	- Active: the namespace is in use and all operations can be performed normally. This is the default phase when a namespace is created. \n
	- Terminating: the namespace has been requested for deletion. No new resources can be created in it. Kubernetes is deleting all resources and waiting for finalizers to complete. Once all resources and finalizers are cleared, the namespace is removed from the API server. \n
	Un Namespace a deux phases possibles : Active (le namespace est en cours d'utilisation, toutes les operations sont possibles) et Terminating (la suppression a ete demandee, plus aucune nouvelle ressource ne peut etre creee, Kubernetes supprime toutes les ressources et attend la fin des finalizers).


# =============================================================================
# NODE
# =============================================================================

topic: ~node (node nodes noeud noeuds kubelet condition conditions taint taints toleration tolerations capacity allocatable)

#! what is a node
u: (<< [what que "qu est-ce"] [is est] [a un une] node >>)
	^keep() A Node is a worker machine in Kubernetes, either physical or virtual. Each Node is managed by the control plane and runs the kubelet agent, a container runtime (like containerd or CRI-O), and kube-proxy. The kubelet registers the Node with the API server and reports its status. Nodes provide the compute resources (CPU, memory, storage) where Pods are scheduled and run. \n
	Un Node est une machine de travail dans Kubernetes, physique ou virtuelle. Chaque Node est gere par le plan de controle et execute l'agent kubelet, un runtime de conteneurs (comme containerd ou CRI-O) et kube-proxy. Le kubelet enregistre le Node aupres du serveur API et rapporte son statut. Les Nodes fournissent les ressources de calcul (CPU, memoire, stockage) ou les Pods sont planifies et executes.

#! node conditions
u: (<< node [condition conditions etat etats status statut] >>)
	^keep() Node conditions describe the current state of a Node. Key conditions include: \n
	- Ready: True if the node is healthy and ready to accept Pods. False if the node is unhealthy. Unknown if the node controller has not heard from the node within the node-monitor-grace-period (default 40s). \n
	- MemoryPressure: True if memory is running low on the node. The kubelet will begin evicting Pods. \n
	- DiskPressure: True if disk capacity is running low. The kubelet reclaims space by garbage collecting dead containers and unused images. \n
	- PIDPressure: True if there are too many processes running on the node. \n
	- NetworkUnavailable: True if the network for the node is not correctly configured (e.g. missing CNI plugin). \n
	Les conditions d'un Node decrivent son etat actuel : Ready (sain et pret a accepter des Pods), MemoryPressure (memoire insuffisante, eviction de Pods), DiskPressure (disque insuffisant, nettoyage automatique), PIDPressure (trop de processus) et NetworkUnavailable (reseau mal configure, plugin CNI manquant).

#! node taints and tolerations
u: (<< node [taint taints toleration tolerations] >>)
	^keep() Taints are applied to Nodes to repel Pods that do not tolerate them. A taint has a key, value, and effect. The three effects are: \n
	- NoSchedule: new Pods without a matching toleration will not be scheduled on the node. \n
	- PreferNoSchedule: Kubernetes will try to avoid scheduling Pods without a matching toleration, but it is not guaranteed. \n
	- NoExecute: existing Pods without a matching toleration are evicted, and new Pods will not be scheduled. \n
	Apply a taint with: kubectl taint nodes <node> key=value:effect. Pods declare tolerations in their spec to be scheduled on tainted Nodes. \n
	Les taints sont appliquees aux Nodes pour repousser les Pods qui ne les tolerent pas. Un taint a une cle, une valeur et un effet. Les trois effets sont : NoSchedule (les nouveaux Pods non tolerants ne sont pas planifies), PreferNoSchedule (Kubernetes essaie d'eviter le placement mais sans garantie) et NoExecute (les Pods existants non tolerants sont expulses). Appliquez un taint avec : kubectl taint nodes <node> key=value:effect. Les Pods declarent des tolerations dans leur spec pour etre planifies sur des Nodes tainted.

#! node capacity and allocatable resources
u: (<< node [capacity capacite allocatable allouable ressource resources] >>)
	^keep() Each Node reports two sets of resource information: \n
	- capacity: the total amount of resources the Node has (CPU, memory, ephemeral-storage, hugepages, and the maximum number of Pods). \n
	- allocatable: the amount of resources available for scheduling Pods, after subtracting resources reserved for the system (kubelet, OS, kube-reserved, system-reserved, eviction thresholds). \n
	The scheduler uses allocatable values when deciding where to place Pods. View both with 'kubectl describe node <node-name>'. \n
	Chaque Node rapporte deux ensembles de ressources : capacity (total des ressources du Node : CPU, memoire, stockage ephemere, hugepages, nombre max de Pods) et allocatable (ressources disponibles pour les Pods, apres soustraction des reserves systeme pour le kubelet, l'OS et les seuils d'eviction). Le scheduler utilise les valeurs allocatable pour decider du placement des Pods. Consultez les deux avec 'kubectl describe node <nom-du-node>'.


# =============================================================================
# EVENT
# =============================================================================

topic: ~k8s_event (event events evenement evenements journal log warning normal)

#! what is a kubernetes event
u: (<< [what que "qu est-ce"] [is est] [a un une] [event evenement] >>)
	^keep() A Kubernetes Event is an object that reports notable occurrences within the cluster. Events are created by the API server, the kubelet, controllers, and the scheduler to provide visibility into what is happening. Each Event has a type (Normal or Warning), a reason, a message, and references the involved object (Pod, Node, Deployment, etc.). Events are namespaced resources with a short default TTL of one hour. \n
	Un Event Kubernetes est un objet qui signale les occurrences notables au sein du cluster. Les Events sont crees par le serveur API, le kubelet, les controleurs et le scheduler pour donner de la visibilite sur ce qui se passe. Chaque Event a un type (Normal ou Warning), une raison, un message et reference l'objet concerne (Pod, Node, Deployment, etc.). Les Events sont des ressources namespacees avec un TTL par defaut d'une heure.

#! how to view kubernetes events
u: (<< [how comment] [view voir consulter afficher list lister get obtenir watch surveiller] [event events evenement evenements] >>)
	^keep() You can view Kubernetes Events using several methods: \n
	- kubectl get events: lists events in the current namespace, sorted by last timestamp. \n
	- kubectl get events --sort-by='.lastTimestamp': explicitly sorts by time. \n
	- kubectl get events -A: lists events across all namespaces. \n
	- kubectl get events --field-selector type=Warning: filters only Warning events. \n
	- kubectl describe <resource> <name>: shows events related to a specific resource at the bottom of the output. \n
	Events have a default TTL of one hour. For longer retention, use a tool like Kubernetes Event Exporter to forward events to an external logging system. \n
	Vous pouvez consulter les Events Kubernetes avec plusieurs methodes : 'kubectl get events' (liste les events du namespace courant), 'kubectl get events -A' (tous les namespaces), 'kubectl get events --field-selector type=Warning' (filtrer les Warning), 'kubectl describe <ressource> <nom>' (affiche les events lies a une ressource specifique). Les Events ont un TTL par defaut d'une heure. Pour une retention plus longue, utilisez un outil comme Kubernetes Event Exporter pour les transmettre a un systeme de logging externe.
